# The course: "Developing applications using the Spring Framework"

## Lab-01

**On the topic "Перше знайомство з Spring Framework"**

Ця лабораторна робота є вступом до концепції та сутності Spring Framework. Після установки JDK,
проєкт був створений в IDE IntelliJ IDEA Ultimate. Вибір цього IDE був виправданий можливістю повної
підтримки даного проєкту.

- Як зазначено в PRD, нам потрібно було спочатку створити порожній проєкт, який ми насправді
  так.
- Після цього була додана фраза «Hello world», яка успішно зображається на початковій сторінці
- Далі, відповідно до завдання в контрольних питаннях, ми розробили сторінку для команди та кожного члена команди,
  додаючи додаткові
  інформації (вірші).

## Lab-02

**On the topic "Створення та з'єднання компонентів"**

У даній лабораторній роботі було виконано створення за з'єднання компонентів. Для цього були створені компоненти рівня
доступу до даних (@Repository), представлення (@Controller) та сервісів (@Service).

На цей момент, рівень доступу даних згідно з ТЗ виконує роль заглушки, а рівень представлення реалізований на базовому
рівні для мінімального представлення у front-end проєкту. У той самий час рівень сервісів являє собою базову
бізнес-логіку, необхідну для проєкту. А саме, за варіантом 4 була реалізована тема "Форум", а саме:

- Представлені сутності "Тема" та "Пост"
- Представлені ролі "Адмін", "Юзер" та "Гість"
- Залежно від ролей клієнт може виконувати окремі дії, а саме: Гість - переглядати теми та пости, Юзер - створення тем
  та постів, Адмін - створення, видалення, редагування тем.
    - Реалізовано усе через рівень сервісів та представлення, а також використовується чистий фронт енд розроблений на
      базі
      React JS. Посилання на фронт енд частину тут:  https://github.com/nikitochkaa/springfrontkpi.git

**Відповіді на КП:**

1. > Поясніть значення наступних термінів:

    - Inversion of Control (IoC);
      Принцип коли в нас є IoC container
    - IoC container;
      IC контейнер. В нас є контейнер спрінг бута який в собі має кучу бінов и всі ці біни створюються спрінгом.
    - Dependency Injection (DI);
      У повному відношенні з принципом єдиної відповідальності об'єкт віддає турботу про побудову потрібних йому
      залежностей зовнішньому, спеціально призначеному для цього загальному механізму
    - Dependency inversion principle.
      З Solid's Класи залежать від абстракцій а не від конкретних деталей

2. > В чому полягає різниця між анотаціями @Component та @Bean? Опишіть переваги та недоліки створення бінів за
   допомогою
   цих анотацій.

   Різниця в способі об'яви. Різний таргет анотацій. Бін можна створити коли в тебе вже є екземпляр класу
   готовий. А коли є новий шаблон класу бін використовувати незручно через те, що треба тоді писати реалізацію прямо в
   методі

3. > Чому слід уникати ін'єкцій залежностей напряму у поле біна?

   Тому, що воно не зможе тобі його створить в принципі нормально. Воно буде створювати компонент у компоненті, а потім
   знов компонент і компонент і ...

4. > В яких випадках краще використовувати ін'єкції залежностей за допомогою конструкторів, а в яких за допомогою
   сетерів?

   Коли це якийсь сервіс який залежить не від спрінга, то краще робить сетером, щоб можна було поміняти щось
   точково.

5. > В яких випадках краще використовувати біни типу singleton, а в яких prototype?

   Коли, наприклад, потрібне ліниве створення біна:
    - Singleton-біни зазвичай створюються відразу при скануванні.
    - Prototype-біни зазвичай створюються тільки після запиту.
   ####
   А також, коли нам важлива область видимості бінів:
    - Singleton - область видимості за замовчуванням. У контейнері знаходиться всього 1 примірник біна
    - Prototype - В контейнері може знаходиться будь-яку кількість примірників біна.

6. > Чи можливе у Spring Framework створення циркулярних залежностей при ін'єкціях?

   Ні.

7. > Чи може бути в одному проєкті кілька класів з реалізацією якогось інтерфейсу, якщо цей інтерфейс використовується
   для
   ін'єкції залежностей?

   Так.

8. > Чи може бін мати кілька методів, помічених анотацією @Autowired?

   Так.

9. > Чи може бін мати кілька конструкторів, помічених анотацією @Autowired?

   Ні. Конструктор один, сетери можна створить багато разів.

## Lab-03

**On the topic "Використання шаблонізаторів у вебзастосунках"**

У даній лабораторній роботі було виконано створення майже усього фронт енд проєкту.
Як було вказано у минулій лабораторній роботі, посилання на фронт енд частину проєкту буде тут:
https://github.com/nikitochkaa/springfrontkpi.git
Під час роботи, було реалізовано усі необхідні сторінки, з використанням React JS. Реалізовано у вигляді Single Page
Application. Сайт містить форму реєстрації, авторизації, головну сторінку, сторінку новин з кількістю гарних
російських військових, сторінку постів до теми та самих тем.
Реалізовано через проксі(фронт енд - порт 3000, бек енд - порт 8080). Також для реалізації поточної приблизної кількості
мертвих російських військових використано перерахунок через середню кількість за весь період війни.

**Відповіді на КП:**

1. > Для чого потрібен шаблон проєктування MVC.

   MVC (Model-View-Controller) це шаблон проєктування, який розділяє вашу програму на три частини: модель, представлення
   та контролер.
   Модель відповідає за дані та логіку вашої програми. Вона зберігає інформацію та реагує на команди, надсилані їй з
   контролера.
   Представлення - це те, що користувач бачить і взаємодіє з у своєму браузері. Це може бути вебсторінка, мобільний
   додаток або інший інтерфейс користувача.
   Контролер обробляє запити від користувачів та взаємодіє з моделлю, щоб отримати необхідні дані. Потім він передає ці
   дані в представлення, яке їх зображати.
   Мета MVC - розділити різні частини вашої програми, щоб створити більш легко розширювану та легко підтримувану
   програму. Коли ви використовуєте MVC, ви можете змінювати одну частину програми (наприклад, представлення) без того,
   щоб це вплинуло на інші частини (наприклад, модель). Це дозволяє вам розробляти та підтримувати вашу програму з
   меншими зусиллями.
   Також, MVC дозволяє вам поділити вашу програму на більш малі частини, що дозволяє більш легко розробляти та
   підтримувати її. Наприклад, якщо ви розробляєте вебсайт, ви можете використовувати MVC, щоб розділити сторінки
   веб-сайту, форми та кнопки на окремі контролери та моделі, що дозволяє більш легко підтримувати та редагувати
   веб-сайт.
   В цілому, шаблон проєктування MVC дозволяє розробникам створювати більш складні та масштабовані програми.

2. > В чому полягають переваги використання шаблону проєктування Front Controller?

   Шаблон проєктування Front Controller полягає у тому, що усі запити, які надходять на веб-сайт, оброблюються єдиним
   контролером, який відповідає за визначення т

   Переваги використання цього шаблону можуть бути наступними:

   Простіше маніпулювання маршрутизацією: Завдяки тому, що усі запити оброблюються єдиним контролером, можна легко
   керувати маршрутизацією на сайті й логікою, яка виконується для кожного маршруту.

   Легше зробити сайт складним: Завдяки цьому шаблону можна легко додавати нові функції та маршрути на сайт, не
   потребуючи
   змінювати що існує структуру коду.

   Легше підтримувати та оновлювати сайт Завдяки тому, що усі запити оброблюються єдиним контролером, можна легше
   виявити й
   виправити помилки на сайті. Також контролер може виконувати різні дії, такі як аутентифікація та авторизація
   користувачів, перед тим як дозволити доступ до певних ресурсів на сайті, що також може бути корисним для підтримки та
   оновлення сайту.

   Однак, треба мати на увазі, що шаблон Front Controller може бути не найкращим вибором для деяких типів сайтів,
   наприклад, для невеликих сайтів з простою маршрутизацією. У такому випадку може бути краще використати інші шаблони
   проєктування, такі як Model-View-Controller (MVC).

3. > Поясніть особливості використання шаблону проєктування Front Controller при реалізації вебзастосунків та RESTful
   вебсервісів.

   Front Controller - це шаблон проєктування, який забезпечує централізоване керування запитами, що надходять до
   вебзастосунку. В такому випадку усі запити, що надходять до вебзастосунку, перенаправляються на одну точку входу,
   яка називається Front Controller. Цей контролер відповідає за розпізнавання запитів та визначення того, які дії
   потрібно виконати в відповідності до цього запиту.

   Однією з основних особливостей Front Controller є те, що він забезпечує розділення логіки бізнес-процесу та
   презентації.
   Це дозволяє розділити код, що відповідає за обробку запитів та генерацію відповіді, від коду, що відповідає за
   презентацію цієї інформації. Це зручно при розробці вебзастосунків, осі при розробці RESTful вебсервісів. RESTful
   вебсервіси є архітектурним стилем, що базується на принципах REST (Representational State Transfer) і дозволяє
   обмінюватися даними між системами за допомогою HTTP протоколу. RESTful вебсервіси використовують стандартні HTTP
   методи, такі як GET, POST, PUT та DELETE, для виконання операцій CRUD (Create, Read, Update, Delete).

   Використання шаблону Front Controller може бути корисним при розробці RESTful вебсервісів, оскільки він дозволяє
   централізовано обробляти всі HTTP запити, які надходять до сервісу, та визначати, які дії потрібно виконати
   відповідно
   до типу запиту та ресурсу, на який він надходить. Це дозволяє розділити логіку обробки запитів та генерації
   відповідей
   від логіки доступу до даних та бізнес-процесів, що виконуються сервісом. Це також дозволяє легко налаштувати сервіс,
   щоб
   він відповідав на різні HTTP методи різним способами, що є однією з основних особливостей RESTful архітектури.

4. > В чому полягають відмінності методів GET та POST протоколу HTTP?
   HTTP GET та POST методи використовуються для отримання ресурсів з вебсервер. Однак, є деякі відмінності між цими
   двома методами:

   Метод GET використовується для отримання даних, тоді як POST використовується для створення нових даних.

   Дані, які надсилаються за допомогою GET методу, додаються до URL у вигляді параметрів у вигляді "?parameter=value".
   Наприклад, у випадку запиту GET http://www.example.com/search?q=keyword, сервер отримає запит на отримання ресурсу "
   search" з параметром "q" рівним "keyword". Дані, які надсилаються за допомогою POST методу, надсилаються у тілі
   запиту і
   не відображаються у URL.

   Метод GET має обмеження на розмір даних, які можна надіслати, це обмеження складає близько 2 kb. Метод POST не має
   такого обмеження і може відправляти дані будь-якого розміру.

   Метод GET зазвичай використовується для запитів, які не міняють стан сервера, наприклад, запит на отримання статті з
   блогу. Метод POST використовується для запитів, які можуть змінювати стан сервера, наприклад, створення нового запису
   у блозі.

   У цілому, різниця між GET та POST методами полягає у тому, що GET використовується для отримання даних, тоді як POST
   використовується для створення нових даних. Необхідно вибирати метод GET у тих випадках, коли запит не міняє стан
   сервера, та POST у тих випадках, коли запит може змінювати стан сервера.

5. > Що таке сервлет?

   Сервлет - це програма на Java, що виконується на веб-сервері і обробляє запити клієнтів. Сервлети мають можливість
   приймати запити і відповідати на них, а також доступ до сервлет-контейнера, який надає загальні функції, такі як
   керування життєвим циклом сервлетів і надання доступу до ресурсів сервера.

   Сервлети використовуються для реалізації веб-застосунків і є основною частиною Java Enterprise Edition (Java EE).
   Вони
   можуть бути використані для реалізації різноманітних функцій, таких як обробка форм, аутентифікація користувачів,
   збереження сесій і т.д.

6. > Якими способами передаються данні HTML-форм з клієнта на сервер? В чому полягають їх переваги та недоліки?

   HTML-форми можуть передавати дані на сервер за допомогою методів HTTP, таких як GET та POST.
   Метод GET: використовується для отримання даних з сервера. Параметри форми додаються до URL-адреси у вигляді пар
   ключ-значення, розділених символом "&". Наприклад: "http://example.com/search?q=keyword&sort=newest".

   Метод POST: використовується для відправки даних на сервер. Параметри форми надсилаються у тілі запиту HTTP, тому їх
   не
   бачить користувач.

   Переваги методу GET:
    - Дані форми можна бачити у URL-адресі, що дозволяє створювати закладки і результати форми можна кешувати.
    - Метод GET підходить для пошуку і отримання даних, так як він не міняє стан сервера.
    -
   Недоліки методу GET:
    - Багато браузерів обмежують довжину URL, тому не всі дані форми можуть бути передані

7. > Чи впливає регістр символів при передачі імен параметрів у HTTP-запитах до сервлетів?

   Ні

8. > Чи впливає регістр символів при передачі значень параметрів у HTTP-запитах до сервлетів?

   Ні

9. > В чому полягає різниця між статичними HTML-сторінками та шаблонами сторінок Thymeleaf та JSP?

   Статичні HTML-сторінки - це звичайні файли HTML, які містять статичний вміст і можуть бути відкриті у браузері. Від
   сервера вони отримуються у тому вигляді, у якому були написані, і не містять жодної динаміки.

   Thymeleaf та JSP - це шаблони сторінок, які дозволяють розробникам створювати динамічний вміст вебсторінок. Вони
   містять спеціальні теги, що використовуються для об'єднання динамічного вмісту зі статичним шаблоном HTML. Після
   того,
   як сервер отримає запит на сторінку, він використовує ці шаблони для створення HTML-сторінки, що відповідає запиту.
   Таким чином, шаблони сторінок дозволяють розробникам створювати динамічний вміст, який може змінюватися в залежності
   від
   змінних, що передаються серверу. Це може бути інформація з бази даних, наприклад, список товарів у магазині, чи дані
   користувача, такі як ім'я та адреса.

   Однак, статичні HTML-сторінки та шаблони сторінок мають свої особливості та переваги. Наприклад, статичні
   HTML-сторінки
   прості у створенні та мають більш просту структуру, але вони менш ефективні для створення динамічного вмісту.
   Навпаки,
   шаблони сторінок дозволяють створювати більш складні сторінки з динамічним вмістом, але їх створення може бути більш
   складним і треба мати більше знань програмування.

10. > В чому полягає різниця між сервлетами та JSP-сторінками?

    Сервлети та JSP-сторінки є двома різними типами компонентів, які можуть бути використані для розробки веб-програм. Вони
    мають деякі спільні риси, але також є речі, які відрізняють їх один від одного.

    Сервлети є Java-класами, які реалізують інтерфейс javax.servlet.Servlet. Вони написані на Java і виконуються на сервері,
    що обслуговує вебзапити. Сервлети є ідеальним вибором для обробки вебзапитів, які потребують складної логіки або
    доступу до серверних ресурсів.

    JSP-сторінки натомість є документами HTML або XML, які містять спеціальні теги, які можуть бути розпізнані сервером.
    Під час виконання JSP-сторінки сервер обробляє ці теги і генерує HTML-код, який потім відправляється на клієнта.
    JSP-сторінки є ідеальним вибором для створення статичних або простих вебсторінок, які не потребують складної
    логіки обробки вебзапитів. Вони також можуть бути зручними для розробників, які не володіють Java, через те, що
    використання
    JSP-сторінок не вимагає навчання і використання Java.

    В цілому, сервлети та JSP-сторінки мають різні призначення і можуть бути використані у різних ситуаціях розробки
    вебпрограма. Важливо розуміти ці відмінності та вибирати найбільш відповідний тип компонента для конкретної задачі.

11. > Як виглядає життєвий цикл JSP-сторінки?

    1) Браузер робить запит до сторінки JSP;
    2) Двигун JSP аналізує вміст файлу JSP і створює сервлет
       (статичний вміст транслюється в методи виведення і поміщається метод _jspService(), динамічний вміст транслюється
       в java-код);
    3) Код сервлета компілюється у файл *.class і завантажується у контейнер;
    4) Виконується метод init() сервлета;
    5) Викликається метод _jspService() і сервлет формує відповідь;
    6) Комбінація статичного HTML та графіки з результатом виконання динамічних елементів пересилаються браузеру;

    - У разі подальшого звернення викликається метод _jspService().
    - Сервлет використовується, доки не буде вивантажений з
      контейнера.

12. > Що таке скриптлети та директивні елементи?

    Скриптлети є фрагментами коду, які виконуються у браузері користувача. Ви можете вставляти скриптлети в HTML-документи,
    щоб додати функціональність на веб-сторінку. Скриптлети пишуться мовою програмування, такій як JavaScript.

    Директивні елементи - це HTML-теги, які містять інструкції для браузера, які служать для визначення того, як браузер має
    розпізнавати та зображати веб-сторінку. Наприклад, тег <meta> містить інформацію, яка не зображається на самій
    сторінці, але може використовуватися браузером або іншими програмами для обробки інформації на сторінці.

13. > В чому полягає різниця між директивою <%@ include%> та елементом <jsp:include>?

    Директива <%@ include %> і елемент <jsp:include> обидва служать для того, щоб включити файл або вміст іншого ресурсу до
    сторінки JSP. Однак є декілька різниць між цими двома конструкціями:

    <%@ include %> є директивою JSP, тоді як <jsp:include> є елементом язику JSP Standard Tag Library (JSTL). Це означає, що
    використовуючи <%@ include %>, ви можете включити тільки статичний вміст, тоді як <jsp:include> дозволяє включити
    динамічний вміст, наприклад, результат виконання іншої JSP сторінки або Servlet.

    <%@ include %> використовується на рівні сторінки, тоді як <jsp:include> використовується на рівні елементів. Це
    означає, що <%@ include %> включається у сторінку цілком, а <jsp:include> може бути використаний в тегу будь-якого
    елементу.

14. > Що таке JavaBean? Як їх використовувати у JSP-сторінках?

    JavaBeans є спеціальними Java-класами, які служать для збереження стану (даних) і відповідають певним правилам. Щоб клас
    могли бути вважаний JavaBean, він повинен відповідати наступним критеріям:

    Мати публічний конструктор без аргументів.
    Мати публічні гетери і сетери для всіх полів.
    Бути серіалізованим (реалізувати інтерфейс Serializable).

    JavaBeans можуть бути використані у JSP-сторінках наступним чином:

    Створіть об'єкт JavaBean у JSP-сторінці.
    Встановіть необхідні значення у поля JavaBean за допомогою сетерів.
    Отримайте значення полів JavaBean за допомогою гетерів і використовуйте їх у JSP-сторінці.

15. > В чому полягають переваги/недоліки використання EL та JSTL у порівнянні з такими JSP-елементами як
    вирази (<%=… %>) та скриптлети (<% … %>)?

    Використання EL (Expression Language) та JSTL (JavaServer Pages Standard Tag Library) має декілька переваг порівняно
    з
    виразами та скриптлетами у JSP:

    Простіший синтаксис: EL має спрощений синтаксис, який дозволяє розробникам більш швидко читати та редагувати код.
    Наприклад, замість того, щоб використовувати скриптлети для обчислення виразу, можна просто вказати його у вигляді
    ${expression}.
    Підтримує інтерполяцію рядків: EL підтримує інтерполяцію рядків, що дозволяє розробникам просто перетворювати
    значення
    змінних у стрічки. Наприклад, замість того, щоб використовувати скриптлети для об'єднання рядків, можна просто
    використати символ "+" у виразі ${string1 + string2}.
    Підтримує навігацію по об'єктній структурі: EL дозволяє розробникам навігувати по об'єкт. Так, доповню інформацію
    про
    переваги використання EL та JSTL:

    Підтримує навігацію по об'єктній структурі: EL дозволяє розробникам навігувати по об'єктній структурі, що дозволяє
    доступатися до полів та методів об'єктів за допомогою іменних референсів. Наприклад, у виразі ${person.name}, "
    person"
    є іменним референсом, а "name" є ім'ям поля.
    JSTL надає додаткові функції: JSTL надає бібліотеку стандартних тегів, які містять різні функції, такі як цикли,
    умовні
    оператори, обробка помилок та ін. Це дозволяє розробникам більш швидко реалізувати складні логіки у своїх
    JSP-сторінках.
    Однак, EL та JSTL також мають свої недоліки:

    Неможливість використання всіх Java конструкцій: EL та JSTL обмежені у можкоду та складність розробки.

    У загальному, EL та JSTL можуть бути корисними інструментами для розробників JSP, які шукають спрощення синтаксису
    та
    надання додаткових функцій. Однак, розробники мають бути готові до того, що EL та JSTL можуть працювати повільніше,
    ніж
    інші конструкції JSP та мають обмежені можливості.

16. > В чому полягають переваги/недоліки використання JSTL-елемента <c:out>у порівнянні зі звичайними EL-виразом ${…}
    або JSP-елементом <%=… %>?

    JSTL (JavaServer Pages Standard Tag Library) - це набір стандартних тегів, які можуть бути використані в JSP
    (JavaServer Pages) сторінках для виконання різноманітних операцій, таких як виведення даних, перевірка умов, циклів
    і т. д.

    Елемент <c:out>з JSTL - це тег, який використовується для виведення даних на вебсторінці. Він має кілька атрибутів,
    які дозволяють керувати тим, як і що буде виведено.

    Одна з переваг <c:out> порівняно з ${...} (EL-виразом) є те, що він автоматично екранує HTML-символи, такі як < і >,
    що запобігає зловживанню HTML. Також <c:out>має декілька додаткових атрибутів, які дозволяють керувати тим, як будуть
    виведені дані, такі як визначення значення за замовчуванням і визначення формату.

    Однак, є деякі недоліки використання <c:out>:

    Він може бути незручним в використанні, якщо потрібно вивести багато даних, оскільки потрібно визначати кожен атрибут
    окремо. Деякі програмісти вважають, що EL-вирази ${...} і JSP-елементи <%=... %> є більш читабельними і легшими для
    використання. Зрештою вибір між <c:out>і іншими методами виведення даних залежить від ваших потреб і
    переваг, які ви хочете врахувати. Важливо розуміти, що є різні можливості та варіанти, і вибирати те, що найкраще
    підходить для вашого конкретного випадку.

17. > Який час життя атрибутів на рівнях requestScope, sessionScope, applicationScope? Чи можуть одночасно існувати
    атрибути з однаковими іменами на різних рівнях?

    - requestScope - це рівень скоупу, на якому атрибути існують тільки протягом одного HTTP-запиту.

    - sessionScope - це рівень скоупу, на якому атрибути існують тільки протягом однієї сесії HTTP. Сесія HTTP - це
      період активності користувача на сайті, який запам'ятовується сервером.

    - applicationScope - це рівень скоупу, на якому атрибути існують протягом усього часу життя вебзастосунку.

    Так, можуть існувати атрибути з однаковими іменами на різних рівнях скоупу, однак вони будуть мати різні значення і
    будуть незалежні один від одного.

18. > Що таке XSS-атака? Як зробити сайт стійким до таких атак?

    XSS (Cross-Site Scripting) - це вид комп'ютерного зловживання, при якому злочинець вставляє верхній код
    (часто JavaScript) на сайт, щоб виконати певні дії на комп'ютерах користувачів, що відвідують цей сайт.

    Щоб зробити сайт стійким до XSS-атак, рекомендують:

    - Фільтрувати введені користувачами дані, щоб уникнути вставки небезпечного коду.

    - Використовувати параметри безпеки HTTP, такі як X-XSS-Protection, щоб запобігти виконанню небезпечного коду на
      клієнтській стороні.

    - Використовувати параметри безпеки у контенту, такі як Content-Security-Policy, щоб заборонити виконання
      небезпечного
      коду у браузері.

    Використовувати параметри безпеки у куках, такі як HttpOnly і Secure, щоб заборонити доступ до кук з JavaScript і
    зашифрувати їх при передачі че. SQL Injection - це ще один вид комп'ютерного зловживання, при якому злочинець
    вставляє
    небезпечний код у запит до бази даних, щоб отримати несанкціонований доступ до інформації або виконати
    несанкціоновані
    дії.

    Щоб захистити сайт від SQL Injection, рекомендують:

    - Фільтрувати введені користувачами дані, щоб уникнути вставки небезпечного коду.

    - Використовувати параметризовані запити, щоб запобігти вставці небезпечного коду у запит до бази даних.

    - Обмежувати права доступу до бази даних так, щоб користувачі мали доступ тільки до тих даних і таблиць, до яких їм
      справді потрібно мати доступ.

19. > Поясніть різницю між термінами forward та redirect.

    Forward і redirect - це два різних способи, які можуть використовуватися веб-сервером для переадресування
    користувача на іншу сторінку.

    Forward - це процес, коли веб-сервер просто перенаправляє запит користувача на іншу сторінку, відправляючи йому
    відповідний заголовок HTTP. Користувач не помічає різниці між оригінальною сторінкою і тією, на яку він був
    перенаправлений, так як URL-адреса не змінюється.

    Redirect - це процес, коли веб-сервер перенаправляє користувача на іншу сторінку, відправляючи йому відповідний
    заголовок HTTP із кодом статусу 3xx. При цьому URL-адреса браузера змінюється на адресу сторінки, на яку було зроблено
    перенаправлення.


## Lab-04 

**On the topic "RESTful вебсервіси"**

У даній лабораторній роботі було створено обліковий запис на ресурсах https://swagger.io/ та https://www.postman.com/,
а також встановлено Postman Desktop Agent. За допомогою цих ресурсів було реалізовано CRUD-операції, такі як create, 
read, update, delete, функція фільтрації та пагінації, і обмін між сервером та клієнтом за допомогою коду стану HTTP. У 
swagger описано усі операції які можуть виконуватись застосунком.

**Відповіді на КП:**

1. >Поясніть різницю між вебзастосунками та RESTful вебсервісами.

    Однією з ключових відмінностей між вебзастосунками та веб-службами RESTful є те, що вебзастосунки призначені для 
    використання людьми, тоді як веб-служби RESTful призначені для використання іншими програмними системами. Інша 
    відмінність полягає в тому, що вебзастосунки зазвичай інтерактивні та мають графічний інтерфейс користувача, тоді як 
    веб-сервіси RESTful зазвичай більше зосереджені на наданні набору послуг і не мають інтерфейсу користувача.

2. >Які технології реалізації концепції сервісно-орієнтованої архітектури ви знаєте? Чим RESTful вебсервіси відрізняються від інших підходів?

   Для реалізації сервісно-орієнтованої архітектури використовуються різні технології, такі як:

    - SOAP (Simple Object Access Protocol) - протокол доступу до об'єктів, який використовує XML для передачі повідомлень 
    та WSDL (Web Services Description Language) для опису сервісів.
   
    - XML-RPC - простий протокол, який використовує XML для передачі повідомлень та виконує виклики методів

    - REST (Representational State Transfer) — це архітектурний стиль для створення веб-сервісів. 
    Веб-сервіси RESTful — це веб-сервіси, створені з використанням архітектурного стилю REST.

    Одним із варіантів, чим веб-сервіси RESTful відрізняються від інших підходів, є те, що вони розроблені без збереження стану,
    тобто вони не зберігають жодної інформації про стан клієнта між запитами. Це робить їх придатними для використання в розподілених
    системах, оскільки забезпечує більшу масштабованість і надійність.

    Інша відмінність веб-служб RESTful полягає в тому, що вони використовують методи HTTP (такі як GET, POST, PUT і DELETE) 
    для виконання операцій над ресурсами. Ці ресурси зазвичай представлені як URL-адреси, а операції, які можна виконувати 
    з ними, визначаються методом HTTP, який використовується в запиті.

3. >Поясніть особливості використання шаблону проектування Front Controller при реалізації вебзастосунків та RESTful вебсервісів.

    Шаблон проектування Front Controller використовується для реалізації обробника запитів, який відповідає за обробку 
    всіх запитів, що надходять до веб-сервера. Цей обробник має єдиний вхідний пункт, і він використовується для 
    розпізнавання запиту та визначення, який контролер повинен обробити цей запит.

    При реалізації веб-застосунків, шаблон Front Controller може допомогти забезпечити стандартизацію обробки запитів та 
    зробити код більш читабельним і легко налагоджуваним. Він також може допомогти уникнути дублювання коду, якщо ви 
    використовуєте обробник для обробки запитів, що відповідають наприклад, певним параметрам або типу користувача.

4. >Для реалізації якої чи яких операцій CRUD (create, read, update, delete) можуть використовуватися такі методи протоколу HTTP як GET, POST, PUT, PATCH, DELETE?

    - Метод GET використовується для читання даних.

    - Метод POST використовується для створення нових даних.

    - Метод PUT використовується для оновлення існуючих даних.

    - Метод PATCH використовується для часткового оновлення існуючих даних.

    - Метод DELETE використовується для видалення існуючих даних.
   
    Таким чином, усі операції CRUD можуть бути реалізовані з використанням цих методів HTTP. Проте, це залежить від того,
    як ви реалізуєте свої веб-сервіси і які конкретні методи ви створите для обробки цих операцій.

5. >Що означають поняття «безпечний» та «ідемпотентний» метод HTTP? Чи будь який безпечний метод є ідемпотентним? Чи будь який ідемпотентний метод є безпечним?

    Безпечний метод HTTP - це такий метод, який не змінює стан сервера. Наприклад, методи GET і HEAD є безпечними, 
    тому що вони не змінюють стан сервера. Це означає, що надсилання нескінченного числа запитів з допомогою цього методу
    не призведе до зміни стану сервера.

    Ідемпотентний метод HTTP - це такий метод, який може бути надсилано безкінечно кілька разів з тими ж результатами. 
    Наприклад, метод GET є ідемпотентним, тому що він завжди повертає те саме вміст без будь-якої зміни стану сервера.

    Таким чином, не будь який безпечний метод є ідемпотентним, і не будь який ідемпотентний метод є безпечним. Однак, 
    найпоширеніші безпечні методи (GET і HEAD) також є ідемпотентними.

6. >В чому полягає різниця між анотаціями @Controller та @RestController?

    @Controller це анотація, яка використовується в Spring Framework для позначення класу як контролера. Цей клас буде 
    обробляти запити, що надходять до веб-сервера, і повертати відповідні відгуки.

    @RestController це спеціальний вид контролера, який автоматично перетворює відповіді з методів контролера у форматі 
    JSON або XML. Ви можете використовувати цю анотацію, щоб зробити свої веб-служби RESTful.

    Основна різниця між ними полягає у тому, що @Controller не автоматично перетворює відповіді на запити у форматі JSON 
    або XML, тоді як @RestController це робить автоматично.

7. >В чому полягає різниця між анотаціями @GetMapping та @RequestMapping?

    Анотація @GetMapping є спеціальною формою анотації @RequestMapping, яка обмежує методи обробки запиту лише на 
    HTTP-метод GET. Таким чином, метод, анотований @GetMapping, буде обробляти тільки GET-запити. Наприклад:
    ```
    @GetMapping("/example")
    public String example() {
        return "Hello, World!";
    }
    ```
    Цей метод буде обробляти тільки GET-запити на URL "/example"

    Анотація @RequestMapping, своєю чергою, є більш загальною і дає можливість вказати будь-який HTTP-метод, 
    який підтримується методом обробки запиту. Вона також може використовуватися для вказівки додаткових атрибутів, 
    таких як параметри запиту чи заголовки. Наприклад:
    ```
    @RequestMapping(method = RequestMethod.GET, value = "/example")
    public String example() {
    return "Hello, World!";
    }
    ```
    Цей метод також буде обробляти тільки GET-запити на URL "/example".
    У більшості випадків використання @GetMapping є більш універсальним і зручним.

8. >В яких випадках можуть знадобитися анотації @RequestParam, @PathVariable, @RequestBody?

    Анотація @RequestParam використовується для отримання параметрів з HTTP-запиту. Якщо ви хочете отримати значення 
    параметра "foo" з URL, а сам URL виглядає так - "/example?foo=bar", то значення параметра "foo" буде "bar".

    Анотація @PathVariable використовується для отримання частини URL як частини запиту. Наприклад, якщо URL виглядає 
    так: "/example/{foo}", то при URL "/example/bar", значення параметра "foo" буде "bar".

    Анотація @RequestBody використовується для отримання тіла HTTP-запиту як об'єкта Java. 

9. >Для чого потрібен клас ResponseEntity?

    ResponseEntity є класом в Java, який належить до бібліотеки Spring Framework і використовується для створення HTTP-відповіді.
    Він дає можливість контролювати всі аспекти HTTP-відповіді, такі як статус код, заголовки і тіло відповіді. Він часто 
    використовується у вебсервісах, які будуть використовуватися іншими системами через мережу.

10. >Як за допомогою анотації @Valid здійснювати валідацію даних, які надходять від клієнта?

    Для того, щоб здійснити валідацію даних, які надходять від клієнта за допомогою анотації @Valid, вам потрібно вказати 
    цю анотацію перед аргументом, який містить об'єкт, який потрібно валідувати. Приклад методу, який валідує дані, які надходять
    від клієнта:
    ```
    @PostMapping("/submit")
    public ResponseEntity<String> submitForm(@Valid @RequestBody FormData formData) {
        if (formData.isValid()) {
            // обробка даних
            return ResponseEntity.ok("Success");
        } else {
            return ResponseEntity.badRequest().body("Invalid form data");
        }
    }
    ```
    Де FormData - це клас, який містить дані, які надходять від клієнта і помічений анотаціями JSR-303 
    (наприклад, @NotNull, @Size і т.д.), які використовуються для валідації.

    Після того, як анотація @Valid буде вказана перед аргументом, що містить об'єкт для валідації, Spring автоматично виконає
    валідацію цього об'єкту перед тим, як викликати метод.


## Lab-05

**On the topic "JDBCTemplate"**

У цій лабораторній роботі замість простого використання встановленої бази даних ми вирішили використовувати контейнер у
Docker, як раз саме з нашою базою даних, на СУБД Postgres SQL. Отож, згідно з завданням було створено на рівні Repository 
інтерфейси та класи для реалізації DAO. Кожен DAO містить передбачену ТЗ функціональність, а саме CRUD та декілька методів
пошуку залежно від критеріїв.
На рівні Service створено інтерфейси та класи для реалізації бізнес-логіки. При цьому щонайменше один метод є транзакційним.
На рівні Controller забезпечено доступ до бізнес-логіки через RESTful API.

І врешті решт, за допомогою Postman або Swagger UI проведено тестування розробленого API.
Окремо перевірено як спрацьовують транзакційні методи у випадках відсутності та наявності помилок.

**Відповіді на КП:**

1. > Поясніть різницю між JDBC та JdbcTemplate.

    JDBC (Java Database Connectivity) є низкорівневим API, яке надає зв'язок між Java-програмами та базами даних. JDBC надає
    механізми для виконання SQL-запитів та обробку результатів, але він не надає шаблонів або зручностей для повторного 
    використання коду або автоматизації повторюваних задач.

    JdbcTemplate є шаблоном для JDBC, який надає шаблони та зручності для повторного використання коду та автоматизації 
    повторюваних задач, таких як виконання SQL-запитів, обробка результатів, управління транзакціями та обробка помилок.

    Таким чином, JdbcTemplate є шаблоном, який використовує JDBC для надання зручних шаблонів та функцій для роботи з 
    базами даних у Java-програмах.

2. > Які переваги надає PreparedStatement у порівнянні зі звичайним Statement?

    PreparedStatement має декілька переваг над звичайним Statement:

    Компіляція запиту: Prepared Statement компілюється базою даних, тоді як звичайний Statement транслюється кожен раз, коли
    його використовують. Це може значно покращити продуктивність програми.

    Безпека: Prepared Statement захищає від атак SQL injection, тому що параметри передаються у вигляді окремих аргументів, 
    а не як частина запиту.

    Ефективність: Prepared Statement може бути використаний багато разів з використанням різних параметрів. База даних може 
    кешувати виконання Prepared Statement і використовувати кеш при наступному використанні. Це може значно покращити 
    продуктивність.

3. > Поясніть різницю між методами execute(), executeQuery() та executeUpdate() класу PreparedStatement.

    PreparedStatement є класом у Java, який дозволяє виконувати SQL-запити зі змінними, які підставляються у запит. 
    Це забезпечує безпеку та ефективність, оскільки запит парситься та підготовлюється один раз, а потім може бути виконаний
    багато разів з різними значеннями.

    Метод execute() використовується для виконання SQL-запиту, який може не повертати жодних даних 
    (наприклад, INSERT, UPDATE, DELETE). Він повертає true, якщо запит оновив хоча б одну строку, і false, якщо ні.

    Метод executeQuery() використовується для виконання SELECT-запиту, який повертає результати у вигляді ResultSet. Він не 
    повертає жодних інших даних.

    Метод executeUpdate() також використовується для виконання запитів, які не повертають даних (INSERT, UPDATE, DELETE), та
    повертає число строк, які були змінені а чи вилучені.

    У цьому випадку executeUpdate() є найбільш ефективним варіантом, так як він повертає тільки число рядків, які були змінені,
    а не цілий ResultSet. Однак, якщо вам необхідно отримати результати запиту, вам необхідно буде використовувати executeQuery().

4. > Чим відрізняються інтерфейси RowMapper<T> та ResultSetExtractor<T>?

    RowMapper<T> і ResultSetExtractor<T> - це інтерфейси, які використовуються для обробки результатів запитів SQL, отриманих 
    з бази даних. Обидва ці інтерфейси містять метод extractData, який викликається із Spring's JdbcTemplate після виконання запиту.

    Однак, інтерфейс RowMapper<T> використовується для обробки окремих рядків результату, тоді як інтерфейс ResultSetExtractor<T> 
    використовується для обробки всього результату запиту цілком.

    Таким чином, якщо вам потрібно обробити всі рядки результату запиту і повернути один результат, то ви можете використати 
    інтерфейс ResultSetExtractor<T>. Якщо ж вам потрібно обробити кожен рядок окремо і повернути список результатів, то ви 
    можете використати інтерфейс RowMapper<T>.

5. > Для чого потрібен інтерфейс KeyHolder?

    KeyHolder це інтерфейс, який містить тільки один метод, getKey(), 
    який повертає об'єкт типу Key. Цей інтерфейс може бути використаний для того, щоб показати, що деякий об'єкт має 
    можливість надати доступ до певного ключа. Наприклад, якщо у вас є сервіс, який зашифровує і розшифровує дані, ви 
    можете визначити інтерфейс KeyHolder і реалізувати його у класі, який зберігає ключ шифрування. Таким чином, інші 
    об'єкти можуть отримати доступ до цього ключа, якщо вони реалізують цей інтерфейс.

6. > Як працює декларативне керування транзакціями у Spring Framework?

    В Spring Framework є декларативний підхід до керування транзакціями, який використовує аннотації або XML-файли для 
    конфігурування транзакцій. Так, ви можете вказати методи, які повинні бути оброблені як транзакції, а також налаштувати 
    умови транзакцій (наприклад, умови завершення транзакції) за допомогою аннотацій.

    Наприклад, якщо ви хочете вказати, що метод повинен бути оброблений як транзакція, ви можете використати аннотацію 
    @Transactional. Також ви можете використати цю аннотацію, щоб налаштувати умови транзакції, такі як режим повернення 
    (наприклад, надійне або ненадійне) і режим перехоплення (наприклад, перехоплювати чи ні).

    Наприклад, якщо ви хочете оновити баланс рахунку і залишок коштів у системі, ви можете написати метод, який буде 
    оброблений як транзакція, так що якщо при виконанні операцій сталася помилка, то будуть відкотитися всі зміни, 
    що зроблені в рамках цієї транзакції.

    ```
   @Transactional
    public void updateAccountBalance(long accountId, double delta) {
        Account account = accountRepository.findById(accountId);
        account.setBalance(account.getBalance() + delta);
        accountRepository.save(account);

        double newTotalBalance = balanceService.getTotalBalance() + delta;
        balanceService.setTotalBalance(newTotalBalance);}
   ```

    У цьому прикладі метод updateAccountBalance буде оброблений як транзакція. Якщо при виконанні операцій з збереженням 
    або оновленням рахунку або тотального балансу сталася помилка, то всі зміни, що зроблені в рамках цієї транзакції, 
    будуть відкотитися.

7. > Що таке «transaction propagation»? Як обрати потрібний механізм поширення транзакцій? Який механізм поширення 
транзакцій використовується за замовченням? 

    Transaction propagation у Джаві - це механізм, який визначає, як буде поширена транзакція між різними методами і класами.

    Щоб обрати потрібний механізм поширення транзакцій, необхідно використати аннотацію @Transactional із параметром propagation.
    Доступні наступні значення:

    - REQUIRED - транзакція буде використана, якщо вже є активна транзакція, інакше буде створена нова транзакція. Це значення
    використовується за замовченням.
    - REQUIRES_NEW - завжди створюється нова транзакція, і стара транзакція призупиняється.
    - MANDATORY - транзакція повинна бути активною, інакше виникає помилка.
    - NOT_SUPPORTED - транзакція призупиняється, якщо є активна транзакція.
    - NEVER - транзакція не повинна бути активною, інакше виникає помилка.
    - SUPPORTS - транзакція буде використана, якщо є активна транзакція, інакше виконуватиметься без транзакції.

    Використовуючи анотацію @Transactional із параметром propagation, можна контролювати, як буде поширена транзакція у 
    методах і класах, що використовують її. За замовченням використовується механізм REQUIRED, тобто транзакція буде використана,
    якщо вже є активна транзакція, інакше буде створена нова транзакція.


## Lab-06

**On the topic "Spring Data"**

У даній роботі замість створення окремого проєкту ми реалізували все на вже створеному. Модернізація торкнулась рівня 
Repository, а саме створено інтерфейси на основі CrudRepository для роботи з @Entity-класами.
Передбачені методи пошуку інформації за:
- запитами на JPQL
- анотацією @Query
- анотацією @NamedQuery
- методами пошуку Spring Data JPA, автоматично згенерованих фреймворком по назві.

За допомогою Postman або Swagger UI проведіть тестування розробленого API.
Окремо перевірте як спрацьовують транзакційні методи у випадках відсутності та наявності помилок.

**Відповіді на КП:**

1. > Що таке ORM?

    ORM (Object-relational mapping) — технологія програмування, яка зв'язує бази даних
    з концепціями об'єктно-орієнтовних мов програмування, створюючи «віртуальну об'єктну базу даних».

2. > В чому полягає різниця між JPA та Hibernate?
   
    Однією з ключових відмінностей між JPA та Hibernate є те, що JPA є специфікацією, тоді як Hibernate є реалізацією цієї 
    специфікації. Це означає, що JPA визначає набір стандартних API, які повинні бути реалізовані будь-яким інструментом ORM,
    який відповідає специфікації JPA, тоді як Hibernate є спеціальним інструментом ORM, який має власний набір функцій і 
    можливостей на додаток до тих, що визначені JPA.

    Ще одна відмінність полягає в тому, що JPA — це стандарт, визначений спільнотою Java, тоді як Hibernate розробляється 
    та підтримується командою Hibernate. Це означає, що JPA призначений як стандартний портативний спосіб роботи з базами 
    даних із Java, тоді як Hibernate може мати більше можливостей і функцій, але також може бути більш прив’язаним до 
    конкретних деталей реалізації.

3. > Поясніть призначення кожного методу з інтерфейсу CrudRepository.

    CrudRepository — це інтерфейс у Spring Framework, який забезпечує основні операції CRUD (Створення, читання, оновлення, видалення)
    для певного типу сутності. Інтерфейс параметризований, з типом сутності та типом поля ID сутності як аргументів типу.

    Ось коротке пояснення призначення кожного з методів в інтерфейсі CrudRepository:

    - `save(S entity)`: зберігає вказану сутність у репозиторій. Якщо сутність вже існує, вона оновлюється. Якщо сутність не 
    існує, вона вставляється.

    - `findById(ID id)`: Отримує сутність за її ідентифікатором. Повертає необов’язковий об’єкт, який може бути порожнім, якщо
    сутність не знайдено.

    - `existsById(ID id)`: визначає, чи існує сутність із заданим ідентифікатором у сховищі. Повертає логічне значення.

    - `findAll()`: отримує всі сутності зі сховища.

    - `findAllById(Iterable<ID> ids)`: отримує зі сховища всі сутності з заданими ідентифікаторами.

    - `count()`: підраховує кількість сутностей у сховищі.

    - `deleteById(ID id)`: видаляє сутність із заданим ідентифікатором зі сховища.

    - `delete(T entity)`: видаляє вказану сутність зі сховища.

    - `deleteAll(Iterable<? extends T> entities)`: видаляє дані сутності зі сховища.

    - `deleteAll()`: видаляє всі сутності зі сховища.

4. > Яким вимогам має відповідати @Entity-клас?

    1) Клас повинен бути анотований анотацією @Entity.
    2) Клас повинен мати конструктор без аргументів.
    3) Клас повинен мати принаймні одне поле з анотацією @Id, яка позначає його як первинний ключ сутності.

   На додаток до цих вимог, класи сутностей також зазвичай визначають поля, які відповідають стовпцям у базі даних, і 
   використовують анотації, такі як @Column і @OneToMany, щоб визначити відображення між полями та стовпцями бази даних.

5. > Які є типи відношень між сутностями у JPA?
   
    JPA (Java Persistence API) реалізує типи відношень між сутностями, які можуть бути представлені у базі даних, 
    за допомогою анотацій:

    - @OneToOne - один-до-одного
    - @OneToMany - один-до-багатьох
    - @ManyToOne - багато-до-одного
    - @ManyToMany - багато-до-багатьох

6. > Для чого потрібні DTO? Чому замість них не завжди можна використовувати @Entity об’єкти?

    DTO (Data Transfer Object) - це об'єкт, який використовується для передачі даних між шарами вашої архітектури. Він не має
    спеціального статусу у програмному забезпеченні та не має жодних анотацій JPA. Він просто містить поля для передачі даних
    та, як правило, не містить жодних бізнес-логіки.

    DTO використовуються, щоб уникнути передачі непотрібної інформації між шарами вашої архітектури. Наприклад, якщо у вас є
    сутність "Product", яка містить декілька полів та зв'язків з іншими сутностями, то ви можете створити DTO "ProductDTO", 
    який буде містити тільки ті поля сутності "Product", які справді необхідні для передачі на клієнт. Це дозволить знизити 
    навантаження на ресурси та прискорити передачу даних.

    Іноді може бути незручно використовувати @Entity об'єкти замість DTO для передачі даних між шарами вашої архітектури,
    тому що сутності, які анотовані як @Entity, мають спеціальний статус у JPA та містять бізнес-логіку. Також сутності 
    можуть мати зв'язки з іншими сутностями та можуть бути збережені у базі даних.

    Використання @Entity об'єктів для передачі даних між шарами може призвести до навантаження на ресурси та повільнішої 
    роботи системи, тому що потрібно буде завантажувати всі зв'язані сутності та виконувати бізнес-логіку, що може бути 
    непотрібно для передачі даних. Також це може викликати проблеми у безпеці, тому що наведені сутності можуть містити чутливі 
    дані, які не повинні бути передані

